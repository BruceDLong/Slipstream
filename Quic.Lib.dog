//############ Quic
requirements = [
    [tagOneOf, Lang, [CPP]]
]

interface={
    provides=[GUI_ToolKit_implementation]
    libFiles=[`pkg-config --cflags --libs gtk+-3.0`]
    headers=[lsquic.h, ev.c]
}

LibDescription ={
    useStatus   = static
    description ='Interface to the quic protocol'
}

embedVeryHigh = `
struct lsQuicMgr{
    // Common elements needed by both client and server:
    enum {
        QuicSERVER  = 1 << 0,
    }                           flags;
    int                         sock_fd;    /* socket */
    ev_io                       sock_w;     /* socket watcher */
    ev_timer                    timer;
    struct ev_loop             *loop;
    lsquic_engine_t            *engine;
    struct sockaddr_storage     local_sas;
    union
    {
        struct client
        {
            ev_io               stdin_w;    /* stdin watcher */
            struct lsquic_conn *conn;
            size_t              sz;         /* Size of bytes read is stored here */
            char                buf[0x100]; /* Read up to this many bytes */
        }   c;
    }                   u;
};

static void process_conns (lsQuicMgr *);  // Forward decl

//// Log file routines
static int log_buf (void *ctx, const char *buf, size_t len){
    FILE *out = ctx;
    fwrite(buf, 1, len, out);
    fflush(out);
    return 0;
}
static const struct lsquic_logger_if logger_if = { log_buf, };

static FILE *logFileHandle;
static int s_verbose;
static void LOG (const char *fmt, ...){
    if (s_verbose){
        va_list ap;
        fprintf(logFileHandle, "LOG: ");
        va_start(ap, fmt);
        (void) vfprintf(logFileHandle, fmt, ap);
        va_end(ap);
        fprintf(logFileHandle, "\n");
    }
}

static SSL_CTX *s_ssl_ctx;

static int load_cert (const char *cert_file, const char *key_file){
    int rv = -1;

    s_ssl_ctx = SSL_CTX_new(TLS_method());
    if (!s_ssl_ctx)
    {
        LOG("SSL_CTX_new failed");
        goto end;
    }
    SSL_CTX_set_min_proto_version(s_ssl_ctx, TLS1_3_VERSION);
    SSL_CTX_set_max_proto_version(s_ssl_ctx, TLS1_3_VERSION);
    SSL_CTX_set_default_verify_paths(s_ssl_ctx);
    if (1 != SSL_CTX_use_certificate_chain_file(s_ssl_ctx, cert_file))
    {
        LOG("SSL_CTX_use_certificate_chain_file failed");
        goto end;
    }
    if (1 != SSL_CTX_use_PrivateKey_file(s_ssl_ctx, key_file,
                                                            SSL_FILETYPE_PEM))
    {
        LOG("SSL_CTX_use_PrivateKey_file failed");
        goto end;
    }
    rv = 0;

  end:
    if (rv != 0)
    {
        if (s_ssl_ctx)
            SSL_CTX_free(s_ssl_ctx);
        s_ssl_ctx = NULL;
    }
    return rv;
}
static SSL_CTX *get_ssl_ctx (void *peer_ctx){
    return s_ssl_ctx;
}
enum ctl_what{
    CW_SENDADDR = 1 << 0,
    CW_ECN      = 1 << 1,
};

//////////

static void setup_control_msg (struct msghdr *msg, enum ctl_what cw, const struct lsquic_out_spec *spec, unsigned char *buf, size_t bufsz){
    struct cmsghdr *cmsg;
    struct sockaddr_in *local_sa;
    struct sockaddr_in6 *local_sa6;
    struct in_pktinfo info;
    struct in6_pktinfo info6;
    size_t ctl_len;

    msg->msg_control    = buf;
    msg->msg_controllen = bufsz;

    /* Need to zero the buffer due to a bug(?) in CMSG_NXTHDR.  See
     * https://stackoverflow.com/questions/27601849/cmsg-nxthdr-returns-null-even-though-there-are-more-cmsghdr-objects
     */
    memset(buf, 0, bufsz);

    ctl_len = 0;
    for (cmsg = CMSG_FIRSTHDR(msg); cw && cmsg; cmsg = CMSG_NXTHDR(msg, cmsg))
    {
        if (cw & CW_SENDADDR)
        {
            if (AF_INET == spec->dest_sa->sa_family)
            {
                local_sa = (struct sockaddr_in *) spec->local_sa;
                memset(&info, 0, sizeof(info));
                info.ipi_spec_dst = local_sa->sin_addr;
                cmsg->cmsg_level    = IPPROTO_IP;
                cmsg->cmsg_type     = IP_PKTINFO;
                cmsg->cmsg_len      = CMSG_LEN(sizeof(info));
                ctl_len += CMSG_SPACE(sizeof(info));
                memcpy(CMSG_DATA(cmsg), &info, sizeof(info));
            }
            else
            {
                local_sa6 = (struct sockaddr_in6 *) spec->local_sa;
                memset(&info6, 0, sizeof(info6));
                info6.ipi6_addr = local_sa6->sin6_addr;
                cmsg->cmsg_level    = IPPROTO_IPV6;
                cmsg->cmsg_type     = IPV6_PKTINFO;
                cmsg->cmsg_len      = CMSG_LEN(sizeof(info6));
                memcpy(CMSG_DATA(cmsg), &info6, sizeof(info6));
                ctl_len += CMSG_SPACE(sizeof(info6));
            }
            cw &= ~CW_SENDADDR;
        }
        else if (cw & CW_ECN)
        {
            if (AF_INET == spec->dest_sa->sa_family)
            {
                const int tos = spec->ecn;
                cmsg->cmsg_level = IPPROTO_IP;
                cmsg->cmsg_type  = IP_TOS;
                cmsg->cmsg_len   = CMSG_LEN(sizeof(tos));
                memcpy(CMSG_DATA(cmsg), &tos, sizeof(tos));
                ctl_len += CMSG_SPACE(sizeof(tos));
            }
            else
            {
                const int tos = spec->ecn;
                cmsg->cmsg_level = IPPROTO_IPV6;
                cmsg->cmsg_type  = IPV6_TCLASS;
                cmsg->cmsg_len   = CMSG_LEN(sizeof(tos));
                memcpy(CMSG_DATA(cmsg), &tos, sizeof(tos));
                ctl_len += CMSG_SPACE(sizeof(tos));
            }
            cw &= ~CW_ECN;
        }
        else
            assert(0);
    }

    msg->msg_controllen = ctl_len;
}

static int packets_out_v1 (void *packets_out_ctx, const struct lsquic_out_spec *specs, unsigned count){
// A more complicated version of ea_packets_out -- this one sets source IP address and ECN.
    lsQuicMgr *const quicMgr = packets_out_ctx;
    unsigned n;
    int fd, s = 0;
    struct msghdr msg;
    enum ctl_what cw;
    union {
        /* cmsg(3) recommends union for proper alignment */
        unsigned char buf[
            CMSG_SPACE(MAX(sizeof(struct in_pktinfo),
                sizeof(struct in6_pktinfo))) + CMSG_SPACE(sizeof(int))
        ];
        struct cmsghdr cmsg;
    } ancil;

    if (0 == count)
        return 0;

    n = 0;
    msg.msg_flags = 0;
    do
    {
        fd                 = (int) (uint64_t) specs[n].peer_ctx;
        msg.msg_name       = (void *) specs[n].dest_sa;
        msg.msg_namelen    = (AF_INET == specs[n].dest_sa->sa_family ?
                                            sizeof(struct sockaddr_in) :
                                            sizeof(struct sockaddr_in6)),
        msg.msg_iov        = specs[n].iov;
        msg.msg_iovlen     = specs[n].iovlen;

        /* Set up ancillary message */
        if (quicMgr->flags & QuicSERVER)
            cw = CW_SENDADDR;
        else
            cw = 0;
        if (specs[n].ecn)
            cw |= CW_ECN;
        if (cw)
            setup_control_msg(&msg, cw, &specs[n], ancil.buf,
                                                    sizeof(ancil.buf));
        else
        {
            msg.msg_control    = NULL;
            msg.msg_controllen = 0;
        }

        s = sendmsg(fd, &msg, 0);
        if (s < 0)
        {
            LOG("sendmsg failed: %s", strerror(errno));
            break;
        }
        ++n;
    }
    while (n < count);

    if (n < count)
        LOG("could not send all of them");    /* TODO */

    if (n > 0)
        return n;
    else
    {
        assert(s < 0);
        return -1;
    }
}

//////// Client callbacks
static lsquic_conn_ctx_t * client_on_new_conn (void *stream_if_ctx, struct lsquic_conn *conn){
    lsQuicMgr *const quicMgr = stream_if_ctx;
    quicMgr->u.c.conn = conn;
    LOG("created connection");
    return (void *) quicMgr;
}
static void client_on_hsk_done (lsquic_conn_t *conn, enum lsquic_hsk_status status){
    lsQuicMgr *const quicMgr = (void *) lsquic_conn_get_ctx(conn);

    switch (status)
    {
    case LSQ_HSK_OK:
    case LSQ_HSK_RESUMED_OK:
        LOG("handshake successful, start stdin watcher");
        ev_io_start(quicMgr->loop, &quicMgr->u.c.stdin_w);
        break;
    default:
        LOG("handshake failed");
        break;
    }
}
static void client_on_conn_closed (struct lsquic_conn *conn){
    lsQuicMgr *const quicMgr = (void *) lsquic_conn_get_ctx(conn);

    LOG("client connection closed -- stop reading from socket");
    ev_io_stop(quicMgr->loop, &quicMgr->sock_w);
}
static lsquic_stream_ctx_t *client_on_new_stream (void *stream_if_ctx, struct lsquic_stream *stream){
    lsQuicMgr *quicMgr = stream_if_ctx;
    LOG("created new stream, we want to write");
    lsquic_stream_wantwrite(stream, 1);
    // return quicMgr: we don't have any stream-specific context
    return (void *) quicMgr;
}
static void client_on_read_v0 (struct lsquic_stream *stream, lsquic_stream_ctx_t *h){
// Echo whatever comes back from server, no verification
    lsQuicMgr *quicMgr = (lsQuicMgr *) h;
    ssize_t nread;
    unsigned char buf[3];

    nread = lsquic_stream_read(stream, buf, sizeof(buf));
    if (nread > 0)
    {
        fwrite(buf, 1, nread, stdout);
        fflush(stdout);
    }
    else if (nread == 0)
    {
        LOG("read to end-of-stream: close and read from stdin again");
        lsquic_stream_shutdown(stream, 0);
        ev_io_start(quicMgr->loop, &quicMgr->u.c.stdin_w);
    }
    else
    {
        LOG("error reading from stream (%s) -- exit loop");
        ev_break(quicMgr->loop, EVBREAK_ONE);
    }
}
static size_t client_readf_v1 (void *ctx, const unsigned char *data, size_t len, int fin){
    if (len)
    {
        fwrite(data, 1, len, stdout);
        fflush(stdout);
    }
    return len;
}
static void client_on_read_v1 (struct lsquic_stream *stream, lsquic_stream_ctx_t *h){
/* Same functionality as client_on_read_v0(), but use a readf callback */
    lsQuicMgr *quicMgr = (lsQuicMgr *) h;
    ssize_t nread;

    nread = lsquic_stream_readf(stream, client_readf_v1, NULL);
    if (nread == 0)
    {
        LOG("read to end-of-stream: close and read from stdin again");
        lsquic_stream_shutdown(stream, 0);
        ev_io_start(quicMgr->loop, &quicMgr->u.c.stdin_w);
    }
    else if (nread < 0)
    {
        LOG("error reading from stream (%s) -- exit loop");
        ev_break(quicMgr->loop, EVBREAK_ONE);
    }
}
struct client_read_v2_ctx {
// Alternatively, pass `stream' to lsquic_stream_readf() and call lsquic_stream_get_ctx() to get lsQuicMgr *
    lsQuicMgr      *quicMgr;
    lsquic_stream_t *stream;
};
static size_t client_readf_v2 (void *ctx, const unsigned char *data, size_t len, int fin){
    struct client_read_v2_ctx *v2ctx = ctx;
    if (len) fwrite(data, 1, len, stdout);
    if (fin){
        fflush(stdout);
        LOG("read to end-of-stream: close and read from stdin again");
        lsquic_stream_shutdown(v2ctx->stream, 0);
        ev_io_start(v2ctx->quicMgr->loop, &v2ctx->quicMgr->u.c.stdin_w);
    }
    return len;
}
static void client_on_read_v2 (struct lsquic_stream *stream, lsquic_stream_ctx_t *h){
// A bit different from v1: act on fin.  This version saves an extra on_read() call at the cost of some complexity.
    lsQuicMgr *quicMgr = (lsQuicMgr *) h;
    ssize_t nread;

    struct client_read_v2_ctx v2ctx = { quicMgr, stream, };
    nread = lsquic_stream_readf(stream, client_readf_v2, &v2ctx);
    if (nread < 0){
        LOG("error reading from stream (%s) -- exit loop");
        ev_break(quicMgr->loop, EVBREAK_ONE);
    }
}
static void client_on_write (struct lsquic_stream *stream, lsquic_stream_ctx_t *h){
// Write out the whole line to stream, shutdown write end, and switch to reading the response.
    lsquic_conn_t *conn;
    lsQuicMgr *quicMgr;
    ssize_t nw;

    conn = lsquic_stream_conn(stream);
    quicMgr = (void *) lsquic_conn_get_ctx(conn);

    nw = lsquic_stream_write(stream, quicMgr->u.c.buf, quicMgr->u.c.sz);
    if (nw > 0)
    {
        quicMgr->u.c.sz -= (size_t) nw;
        if (quicMgr->u.c.sz == 0)
        {
            LOG("wrote all %zd bytes to stream, switch to reading", (size_t) nw);
            lsquic_stream_shutdown(stream, 1);  /* This flushes as well */
            lsquic_stream_wantread(stream, 1);
        }
        else
        {
            memmove(quicMgr->u.c.buf, quicMgr->u.c.buf + nw, quicMgr->u.c.sz);
            LOG("wrote %zd bytes to stream, still have %zd bytes to write", (size_t) nw, quicMgr->u.c.sz);
        }
    }
    else
    {
        /* When `on_write()' is called, the library guarantees that at least
         * something can be written.  If not, that's an error whether 0 or -1
         * is returned.
         */
        LOG("stream_write() returned %ld, abort connection", (long) nw);
        lsquic_conn_abort(lsquic_stream_conn(stream));
    }
}
static void client_on_close (struct lsquic_stream *stream, lsquic_stream_ctx_t *h){
    LOG("stream closed");
}
static void (*const client_on_read[])(lsquic_stream_t *, lsquic_stream_ctx_t *h) ={
    client_on_read_v0,
    client_on_read_v1,
    client_on_read_v2,
};

static struct lsquic_stream_if client_callbacks = {
    .on_new_conn        = client_on_new_conn,
    .on_hsk_done        = client_on_hsk_done,
    .on_conn_closed     = client_on_conn_closed,
    .on_new_stream      = client_on_new_stream,
    .on_read            = client_on_read_v0,
    .on_write           = client_on_write,
    .on_close           = client_on_close,
};


//////// Server callbacks
static void reverse_string (unsigned char *p, size_t len){
    unsigned char *q, tmp;

    q = p + len - 1;
    while (p < q)
    {
        tmp = *p;
        *p = *q;
        *q = tmp;
        ++p;
        --q;
    }
}

static lsquic_conn_ctx_t * server_on_new_conn (void *stream_if_ctx, struct lsquic_conn *conn){
    lsQuicMgr *const quicMgr = stream_if_ctx;

    LOG("created new connection");
    return (void *) quicMgr;     /* Pointer to quicMgr is the connection context */
}
static void server_on_conn_closed (lsquic_conn_t *conn){
    LOG("closed connection");
}
struct server_stream_ctx {
    size_t           tssc_sz;            /* Number of bytes in tsc_buf */
    off_t            tssc_off;           /* Number of bytes written to stream */
    unsigned char    tssc_buf[0x100];    /* Bytes read in from client */
};
static lsquic_stream_ctx_t * server_on_new_stream (void *stream_if_ctx, struct lsquic_stream *stream){
    struct server_stream_ctx *tssc;

    /* Allocate a new buffer per stream.  There is no reason why the echo
     * server could not process several echo streams at the same time.
     */
    tssc = malloc(sizeof(*tssc));
    if (!tssc)
    {
        LOG("cannot allocate server stream context");
        lsquic_conn_abort(lsquic_stream_conn(stream));
        return NULL;
    }

    tssc->tssc_sz = 0;
    tssc->tssc_off = 0;
    lsquic_stream_wantread(stream, 1);
    LOG("created new echo stream -- want to read");
    return (void *) tssc;
}
static void server_on_read (struct lsquic_stream *stream, lsquic_stream_ctx_t *h){
/* Read until newline and then echo it back */
    struct server_stream_ctx *const tssc = (void *) h;
    ssize_t nread;
    unsigned char buf[1];

    nread = lsquic_stream_read(stream, buf, sizeof(buf));
    if (nread > 0)
    {
        tssc->tssc_buf[ tssc->tssc_sz ] = buf[0];
        ++tssc->tssc_sz;
        if (buf[0] == (unsigned char) '\n'
                            || tssc->tssc_sz == sizeof(tssc->tssc_buf))
        {
            LOG("read newline or filled buffer, switch to writing");
            reverse_string(tssc->tssc_buf,
                            tssc->tssc_sz - (buf[0] == (unsigned char) '\n'));
            lsquic_stream_wantread(stream, 0);
            lsquic_stream_wantwrite(stream, 1);
        }
    }
    else if (nread == 0)
    {
        LOG("read EOF");
        lsquic_stream_shutdown(stream, 0);
        if (tssc->tssc_sz)
            lsquic_stream_wantwrite(stream, 1);
    }
    else
    {
        /* This should not happen */
        LOG("error reading from stream (errno: %d) -- abort connection", errno);
        lsquic_conn_abort(lsquic_stream_conn(stream));
    }
}
static void server_on_write_v0 (struct lsquic_stream *stream, lsquic_stream_ctx_t *h){
    struct server_stream_ctx *const tssc = (void *) h;
    ssize_t nw;

    assert(tssc->tssc_sz > 0);
    nw = lsquic_stream_write(stream, tssc->tssc_buf + tssc->tssc_off,
                                            tssc->tssc_sz - tssc->tssc_off);
    if (nw > 0)
    {
        tssc->tssc_off += nw;
        if (tssc->tssc_off == tssc->tssc_sz)
        {
            LOG("wrote all %zd bytes to stream, close stream",
                                                            (size_t) nw);
            lsquic_stream_close(stream);
        }
        else
            LOG("wrote %zd bytes to stream, still have %zd bytes to write",
                                (size_t) nw, tssc->tssc_sz - tssc->tssc_off);
    }
    else
    {
        /* When `on_write()' is called, the library guarantees that at least
         * something can be written.  If not, that's an error whether 0 or -1
         * is returned.
         */
        LOG("stream_write() returned %ld, abort connection", (long) nw);
        lsquic_conn_abort(lsquic_stream_conn(stream));
    }
}
static size_t tssc_read (void *ctx, void *buf, size_t count){
    struct server_stream_ctx *tssc = ctx;

    if (count > tssc->tssc_sz - tssc->tssc_off)
        count = tssc->tssc_sz - tssc->tssc_off;
    memcpy(buf, tssc->tssc_buf + tssc->tssc_off, count);
    tssc->tssc_off += count;
    return count;
}
static size_t tssc_size (void *ctx){
    struct server_stream_ctx *tssc = ctx;
    return tssc->tssc_sz - tssc->tssc_off;
}
static void server_on_write_v1 (struct lsquic_stream *stream, lsquic_stream_ctx_t *h){
// Same functionality as server_on_write_v0(), but use the "reader" callbacks.  This is most useful when data comes from a different source such as file descriptor.
    struct server_stream_ctx *const tssc = (void *) h;
    struct lsquic_reader reader = { tssc_read, tssc_size, tssc, };
    const size_t left = tssc->tssc_sz;
    ssize_t nw;

    nw = lsquic_stream_writef(stream, &reader);
    if (nw > 0 && tssc->tssc_off == tssc->tssc_sz)
    {
        LOG("wrote all %zd bytes to stream, close stream", left);
        lsquic_stream_close(stream);
    }
    else if (nw < 0)
    {
        LOG("stream_write() returned %ld, abort connection", (long) nw);
        lsquic_conn_abort(lsquic_stream_conn(stream));
    }
}
static void server_on_close (struct lsquic_stream *stream, lsquic_stream_ctx_t *h){
    struct server_stream_ctx *const tssc = (void *) h;
    free(tssc);
    LOG("stream closed");
}
static void (*const server_on_write[])(lsquic_stream_t *, lsquic_stream_ctx_t *) = {
    server_on_write_v0,
    server_on_write_v1,
};

static struct lsquic_stream_if server_callbacks = {
    .on_new_conn        = server_on_new_conn,
    .on_conn_closed     = server_on_conn_closed,
    .on_new_stream      = server_on_new_stream,
    .on_read            = server_on_read,
    .on_write           = server_on_write_v0,
    .on_close           = server_on_close,
};

////////////////

union {
    struct sockaddr     sa;
    struct sockaddr_in  addr4;
    struct sockaddr_in6 addr6;
} Addr;


`

initCode = `
    initQuicEngine()
`

deinitCode = `
    deinitWuicEngine()
`

struct GLOBAL{
    void: initQuicSystem() <- {
        // Initialize logging
        logFileHandle <- stderr;
        setvbuf(logFileHandle, NULL, _IOLBF, 0);
        lsquic_logger_init(logger_if, logFileHandle, LLTS_HHMMSSUS);
        // Initialize quic global engine
        if (0 != lsquic_global_init(LSQUIC_GLOBAL_SERVER|LSQUIC_GLOBAL_CLIENT)){ fprintf(stderr, "global initialization failed\n");exit(EXIT_FAILURE);}
    }
    void: deinitQuicSystem() <- {
        lsquic_global_cleanup();
    }
}

struct quic_engine_settings: wraps = lsquic_engine_settings{
    me int: es_cc_algo
    me int: es_ecn
    me int: es_ql_bits
}

struct QuicMgr: wraps = lsQuicMgr{
    me int: flags
    me int: sock_fd
    me int: local_sas
    me int: ss_family
    me int: engine
    me int: loop
    me int: u
}

struct QuicEngine{
    me QuicMgr: quicMgr
    me Addr: addr
    me string: cert_file
    me string: key_file
    me string: key_log_dir
    me quic_engine_settings: settings
    me int: packets_out_version

    void: init(me string: filenameTag) <- {
  //      client_callbacks.on_read <- client_on_read[ 2 ]   // 0, 1, or 2
        cert_file <- filenameTag+"CertFile.pem"
        key_file  <- filenameTag+"KeyFile.pem"

        logFileHandle <- fopen(filenameTag+".log", "ab")
        if (!logFileHandle){perror("cannot open log file for writing");exit(EXIT_FAILURE);}


        if (0 != lsquic_logger_lopt("event=debug")){fprintf(stderr, "invalid log option\n");exit(EXIT_FAILURE);}
        packets_out_version <- 1   // 0 or 1
        key_log_dir <- filenameTag+"KeyLogDir"
        lsquic_set_log_level(1)
        s_verbose <- 1             // 0=less logging

   //     server_callbacks.on_write <- server_on_write[ 1 ]   // 0 or 1

        settings.es_cc_algo <- 3  // 3 = auto
        settings.es_ecn <- 1      // 0==off, 1==on

        // Parse IP address and port number
/*        if (inet_pton(AF_INET, argv[optind], &addr.addr4.sin_addr)){
            addr.addr4.sin_family <- AF_INET;
            addr.addr4.sin_port   <- htons(atoi(argv[optind + 1]));
        }
        else if (memset(&addr.addr6, 0, sizeof(addr.addr6)),  inet_pton(AF_INET6, argv[optind], &addr.addr6.sin6_addr)){
            addr.addr6.sin6_family <- AF_INET6;
            addr.addr6.sin6_port   <- htons(atoi(argv[optind + 1]));
        }
        else {LOG("`%s' is not a valid IP address", argv[optind]); exit(EXIT_FAILURE);}
*/
        // Specifying certificate and key files indicates server mode
/*        if (cert_file || key_file){
            if (!(cert_file && key_file)) { LOG("Specify both cert (-c) and key (-k) files"); exit(EXIT_FAILURE);  }
            if (0 != load_cert(cert_file, key_file)) { LOG("Cannot load certificate");        exit(EXIT_FAILURE);}
            quicMgr.flags |= QuicSERVER;
        }

        if (!settings_initialized){
  //          lsquic_engine_init_settings(&settings, quicMgr.flags & QuicSERVER ? LSENG_SERVER : 0);
        }
*/
        // At the time of this writing, using the loss bits extension causes decryption failures in Wireshark.  For the purposes of the demo, we override the default.
        settings.es_ql_bits <- 0

        // Check settings
     /*   if (0 != lsquic_engine_check_settings(&settings,
                                quicMgr.flags & QuicSERVER ? LSENG_SERVER : 0,
                                errbuf, sizeof(errbuf)))   { LOG("invalid settings: %s", errbuf); exit(EXIT_FAILURE);}

        }*/


    // Set up socket
        if (quicMgr.sock_fd < 0){perror("socket");                  exit(EXIT_FAILURE);}
        if (0 != set_nonblocking(quicMgr.sock_fd)){ perror("fcntl");exit(EXIT_FAILURE);}
 //       if (0 != set_ecn(quicMgr.sock_fd, &addr.sa))                exit(EXIT_FAILURE);
        if (quicMgr.flags & QuicSERVER){
 //           if (0 != set_origdst(quicMgr.sock_fd, &addr.sa))        exit(EXIT_FAILURE);
        }
        if (quicMgr.flags & QuicSERVER){
            me int: socklen <- sizeof(addr)
  //          if (0 != bind(quicMgr.sock_fd, &addr.sa, socklen)){ perror("bind");exit(EXIT_FAILURE);}
  //          memcpy(&quicMgr.local_sas, &addr, sizeof(addr));
        } else {
  //          quicMgr.local_sas.ss_family <- addr.sa.sa_family
            me int: socklen <- sizeof(quicMgr.local_sas)
   //         if (0 != bind(quicMgr.sock_fd, (struct sockaddr *) &quicMgr.local_sas, socklen)){ perror("bind"); exit(EXIT_FAILURE);}
   //         ev_init(&quicMgr.timer, timer_expired);
        }
   //     ev_io_init(&quicMgr.sock_w, read_socket, quicMgr.sock_fd, EV_READ);
   //     ev_io_start(quicMgr.loop, &quicMgr.sock_w);



    // Initialize callbacks
        me lsquic_engine_api: eapi
  //      memset(&eapi, 0, sizeof(eapi));
  //      eapi.ea_packets_out <- packets_out[packets_out_version]
  //      eapi.ea_packets_out_ctx <- &quicMgr
  //      eapi.ea_stream_if   <- quicMgr.flags & (QuicSERVER ? &server_callbacks : &client_callbacks)
  //      eapi.ea_stream_if_ctx <- &quicMgr
  //      eapi.ea_get_ssl_ctx   <- get_ssl_ctx
        if (key_log_dir){
  //          eapi.ea_keylog_if <- &keylog_if;
  //          eapi.ea_keylog_ctx <- (void *) key_log_dir;
        }
  //      eapi.ea_settings <- settings


   // New Engine
  //      quicMgr.engine <- lsquic_engine_new(quicMgr.flags & (QuicSERVER ? LSENG_SERVER : 0), &eapi);
        if (!quicMgr.engine){ LOG("cannot create engine");                   exit(EXIT_FAILURE);}

  /*      quicMgr.timer.data <- &quicMgr;
        quicMgr.sock_w.data <- &quicMgr;
        if (!(quicMgr.flags & QuicSERVER)){
            if (0 != set_nonblocking(STDIN_FILENO)){ perror("fcntl(stdin)"); exit(EXIT_FAILURE);}
            ev_io_init(&quicMgr.u.c.stdin_w, read_stdin, STDIN_FILENO, EV_READ);
            quicMgr.u.c.stdin_w.data <- &quicMgr;
            quicMgr.u.c.conn <- lsquic_engine_connect(
                quicMgr.engine, N_LSQVER,
                (struct sockaddr *) &quicMgr.local_sas, &addr.sa,
                (void *) (uintptr_t) quicMgr.sock_fd,  // Peer ctx
                NULL, NULL, 0, NULL, 0, NULL, 0
            );
            if (!quicMgr.u.c.conn){LOG("cannot create connection");          exit(EXIT_FAILURE);}
            process_conns(&quicMgr);
        }*/
        ev_run(quicMgr.loop, 0)

    }
}

struct QuicConnection{
}

struct QuicStream{
}
