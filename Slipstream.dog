// Slipstream.dog

LinuxBuild: Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';
//SwingBuild: Platform='Java' CPU='JavaVM' Lang='Java' optimize='speed';
//AndroidBuild: Platform='Android' CPU='JavaVM' Lang='Java' optimize='power';
//iPhoneBuild: Platform='IOS' CPU='amd64' Lang='Swift' optimize='speed';

Title = "The Slipstream Browser"
FileName = "Slipstream"
Version = "1.0"
CopyrightMesg = "Copyright 2020-2021 Bruce Long; All rights reserved."
Authors = "Bruce Long"
Description = "The Slipstream Browser"
ProgramOrLibrary = "program"

featuresNeeded = [GUI_ToolKit, Dashboard, Proteus]

LicenseText = `All rights reserved.`

runCode=`
    logMgr.init(OFile)
    thisApp.loadAndParseSettingsAndData()
    isFirstRun<-true
`
////////////   A p p l i c a t i o n   a n d   G l o b a l s

mainStyle = {
    colors = {
    }
    fontNames = {
    }
    fontSizes = {
        fontSizeSmall     = 8
    }
}


do makeStyler(mainStyle)
do makeGUI(GUI_Spec)

struct GLOBAL{
    me int: vertSepSmall   <- 5
    me int: vertSepMed     <- 30
    me int: vertListWidth  <- 200
    me int: headerHeight <- 25
    me int: horizListOPad  <- 5
    me int: Yborder <- 3
    me int: VListHeaderHeight <- 56

    me int: buttonWidth  <-55
    me int: buttonHeight <-22

    me cdColor: buttonBright <- cdColor(255,255,255,255)
    me cdColor: buttonNormal <- cdColor(200,200,200,200)
    me cdColor: surfaceBkgnd <- cdColor(20,20,20,200)
    me cdColor: popupBkgnd   <- cdColor(20,20,20,250)
    me cdColor: titleTextColr<- cdColor(200,200,200,225)
    me cdColor: taskCardColor<- cdColor(240,245,240,245)
    me cdColor: cardTextColr <- cdColor(20,30,20,200)
    me cdColor: footerBoxColr<- cdColor(80,80,80,200)
}

struct GuiModelManager{

    void: processCommand(our ProactEvent: ev) <- {
        switch(ev.eventType){
        case eAddInfon:  {
            our POV: newPov <- ev.infonX.tryAddingTentativeChild();
            if(newPov){
                newPov.pItem.isTentative<-false;
                CORE.agent.normalize(ev.infonX);
                log("\nAdded Item:"+newPov.stringify())
            } // TODO: give some sign as to why nothing was added
        }
        case eReqRedraw: {}
        case eGUI_SetXY: {}
        case eBlockEvents: {log("BLOCK_EVENT")}
        case eGUI_setStr1: {our GuiDataRec:: GDR; GDR.str1<- ev.text; guiData[ev.dataIdTag] <- GDR}
        //case eGUI_setStr2: {}
        case eGUI_setInt1: {our GuiDataRec:: GDR; GDR.int1<- ev.int1; guiData[ev.dataIdTag] <- GDR; log("setInt1["+ev.dataIdTag+"]:"+toString(ev.int1))}
        //case eGUI_setInt2: {}
        }
        slipView.requestRedraw()
    }
}

struct viewStyles:inherits=<mode[vsDefault, vsX_stack, vsY_stack, vsZ_stack, vsPlotGraph, vsDataView, vsString, vsNumber, vsDate]> {}

struct Presenter{

    void: addLabeledButton(our dashDrawing: dr, me GuiCoords:myCoords, me string: btnLabel) <- {
        me bool: mouseIsOver <- addMouseOverEvents(myCoords)
        me cdColor: buttonColor
        if(mouseIsOver){buttonColor<-buttonBright} else {buttonColor<-buttonNormal}
        dr.addC(cmdSetColor, buttonColor)
        dr.addRA(cmdDrawRect, myCoords)
        dr.add1(cmdFill)

        if(mouseIsOver){dr.addC(cmdSetColor, cardTextColr)}else{dr.addC(cmdSetColor, cardTextColr)}
        dr.addTF(cmdRenderTextCentered, myCoords.X+myCoords.W/2, myCoords.Y+(myCoords.H/2)+(styler.smallFont.height/2-3), btnLabel, styler.smallFont)
        dr.add1(cmdFill)
    }

    void: drawMessageDialog(our dashDrawing: dr, me string: buttonList, me string: Mesg, me GUI_Scalar: posX, me GUI_Scalar: posY, me GUI_Scalar: width, me GUI_Scalar: height, our ProactEvent: btn1Ev, our ProactEvent: btn2Ev) <- {
        me int: buttonWidth  <-65
        me int: buttonHeight <-30

        dr.addC(cmdSetColor, taskCardColor)
        me GuiCoords:RA{posX, posY, width, height}
        dr.addRAA(cmdRoundRect, RA, 13)
        dr.add1(cmdFill)

        our ProactEvent:: blockEvents;
        blockEvents.setTrigger(tPrimaryClick, RA); blockEvents.setGUI_Event1(eBlockEvents)
        registerEvent(blockEvents)

        dr.addC(cmdSetColor, footerBoxColr)
        dr.addTF(cmdRenderTextCentered, posX+width/2, posY+((height-(buttonHeight+5))/2)+(styler.defaultFont.height/2-2), Mesg, styler.defaultFont)
        dr.add1(cmdFill)

        me List<string>: buttons
        me string: btnLabel <- ""
        me int: buttonStrSize <- buttonList.size()
        withEach pos in RANGE(0..buttonStrSize){
            me char: ch<-buttonList[pos]
            if(ch=="|" or pos==buttonStrSize-1){
                if(ch!="|" and pos==buttonStrSize-1){btnLabel <+- ch}
                buttons.pushLast(btnLabel)
                btnLabel <- ""
            }
            else{btnLabel <+- ch}
        }
        me int: numBtns <- buttons.size()
        me int: count <- 0
        withEach label in buttons{
            me GuiCoords:RA{posX + width/numBtns*count+(width/numBtns/2) - buttonWidth/2,   posY+height-(buttonHeight+5), buttonWidth, buttonHeight}
            addLabeledButton(dr, RA, label)
            if(count==0 and btn1Ev!=NULL){btn1Ev.setTrigger(tPrimaryClick, RA)}
            if(count==1 and btn2Ev!=NULL){btn2Ev.setTrigger(tPrimaryClick, RA)}
            count <+- 1
        }
    }

    void: drawUnsizedElement(our dashDrawing: dr, our infon: element, me GUI_Scalar:posX, me GUI_Scalar:posY, their GUI_Scalar: width, their GUI_Scalar:height, me string: viewModeHint) <- {
        our POV: propertiesInf <- fetchField(element, "properties")
        our POV: titleInf      <- fetchField(propertiesInf.pItem, "title")
        me string: title       <- titleInf.pItem.fetchString()
        our POV: dataInf       <- fetchField(element, "data")
        me viewStyles: viewStyle
        if(element.type.asGiven=="kanban"){ viewStyle <- vsX_stack}
        else if(element.type.asGiven=="tasklist"){ viewStyle <- vsY_stack}
        //log("INFON_TYPE:"+element.type.asGiven)
        our POV: screenPos     <- NULL
        our POV: xPov          <- NULL
        our POV: yPov          <- NULL
        if(viewStyle==vsX_stack or viewStyle==vsY_stack){
            screenPos <- fetchField(propertiesInf.pItem, "screenpos")
            if(screenPos!=NULL){
                xPov <- fetchField(screenPos.pItem, "xpos")
                yPov <- fetchField(screenPos.pItem, "ypos")
                posX<-xPov.pItem.fetchDouble()
                posY<-yPov.pItem.fetchDouble()
            }
        }

        if(viewStyle==vsX_stack){
            // Draw Columns
            me GUI_Scalar: itemHeight
            me GUI_Scalar: itemWidth
            draw_X_stack_XYwh(dr, dataInf, posX, posY+headerHeight, itemWidth, itemHeight, "headeredVList")

            // Kanban header
            width <deep- (itemWidth)-posX;
            height <deep- itemHeight+headerHeight;

            dr.addC(cmdSetColor, surfaceBkgnd)
            me GuiCoords:HedrRectXYWH{posX, posY, itemWidth, headerHeight-2};
            dr.addRAA(cmdRoundTopRect, HedrRectXYWH, 15)
            dr.add1(cmdFill)
            if(screenPos!=NULL){
                our ProactEvent:: dragEvent;
                dragEvent.setTrigger(tDragStart, HedrRectXYWH); dragEvent.setInfonEvent(eGUI_SetXY, xPov, yPov)
                registerEvent(dragEvent)
            }

            me GuiCoords:RA1{posX+itemWidth-25, posY+3, 16, 16}
            drawCircleButton(dr, RA1.X, RA1.Y, RA1.W/2, 3, "+", element.mySymbol()+"AddItem")
            our ProactEvent:: addListEvent;
            addListEvent.setTrigger(tPrimaryClick, RA1); addListEvent.setInfonEvent(eAddInfon, dataInf, NULL)
            registerEvent(addListEvent)

            dr.addC(cmdSetColor, titleTextColr)
            dr.addTF(cmdRenderTextCentered, posX+itemWidth/2, posY+(headerHeight/2)+(styler.smallFont.height/2-3), title, styler.smallFont)
        } else if(viewStyle==vsY_stack){
            me GUI_Scalar:yCur <- posY
            dr.addC(cmdSetColor, surfaceBkgnd)
            me GuiCoords:RA{posX, posY, vertListWidth, 0}
            me DrawCmd: dCmd <- cmdRoundRect
            if(viewModeHint=="headeredVList"){dCmd <- cmdRoundBotRect}
            our Drawel: boxDR <- dr.addRAA(dCmd, RA, 15) // Background for lists
            dr.add1(cmdFill)

            // Column Header
            dr.addC(cmdSetColor, titleTextColr)
            dr.addTF(cmdRenderTextCentered, posX+(vertListWidth/2), posY+(VListHeaderHeight/2)+(styler.titleFont.height/2-5), title, styler.titleFont)

            if(screenPos!=NULL){ // Enable dragging
                me GuiCoords:HedrRectXYWH{posX, posY, vertListWidth, VListHeaderHeight};
                our ProactEvent:: dragEvent;
                dragEvent.setTrigger(tDragStart, HedrRectXYWH); dragEvent.setInfonEvent(eGUI_SetXY, xPov, yPov)
                registerEvent(dragEvent)
            }
            // Draw the list body
            yCur <- posY+VListHeaderHeight
            me GUI_Scalar: itemHeight
            draw_Y_stack_XYWh(dr, dataInf, posX, yCur, vertListWidth, itemHeight, "cardView")
            yCur <+- itemHeight

            // Draw the footer
            me int: footerHeight <- 27
            dr.addC(cmdSetColor, footerBoxColr)
            me GuiCoords:RAf{posX+5, yCur, vertListWidth-10, footerHeight-4}
            dr.addRAA(cmdRoundBotRect, RAf, 15)
            dr.add1(cmdFill)

            me GuiCoords:RA1{posX+10, yCur+3, 16, 16}
            drawCircleButton(dr, RA1.X, RA1.Y, RA1.W/2, 3, "menu", element.mySymbol()+"Menu")
            //~ our ProactEvent:: addListEvent1;
            //~ addListEvent1.setTrigger(tPrimaryClick, RA1); addListEvent1.setInfonEvent(eGUI_PopupModal, dataInf, NULL)
            //~ registerEvent(addListEvent1)

            me GuiCoords:RA2{posX+vertListWidth-23, yCur+3, 16, 16}
            drawCircleButton(dr, RA2.X, RA2.Y, RA2.W/2, 3, "+", element.mySymbol()+"AddItem")
            our ProactEvent:: addListEvent2;
            addListEvent2.setTrigger(tPrimaryClick, RA2); addListEvent2.setInfonEvent(eAddInfon, dataInf, NULL)
            registerEvent(addListEvent2)

            yCur <+- footerHeight

            boxDR.h<-yCur-posY
        } else if(element.type.asGiven=="task"){
            me string: text<-title
            if(titleInf.pItem.value.format==fUnknown){text<-"<Empty>"}
            me GUI_Scalar:H2 <- styler.smallFont.height+ Yborder*2
            height <deep- H2
            width  <deep- vertListWidth-5*2
            me GUI_Scalar:W2 <- width
            dr.addC(cmdSetColor, taskCardColor)
            me GuiCoords:RA{posX, posY, W2, H2}
            dr.addRAA(cmdRoundRect, RA, 13)
            dr.add1(cmdFill)

            dr.addC(cmdSetColor, cardTextColr)
            dr.addTF(cmdRenderText, posX+5, posY+(H2/2)+(styler.smallFont.height/2-2), text, styler.smallFont)

            our ProactEvent:: popUptoEditCard;
            popUptoEditCard.setTrigger(tPrimaryClick, RA); popUptoEditCard.setGUI_Store_Int1(dataInf.mySymbol()+"/editCardPopped", 1)
            registerEvent(popUptoEditCard)
        }
    }

    our POV: fetchField(our infon: info, me string: fieldname) <- {
        our POV: retVal <- info.fetchField(fieldname)
        return(retVal)
    }

    void: drawBoardMenu(our dashDrawing: dr, me GUI_Scalar:posX, me GUI_Scalar:posY) <- {
        me int: numboards <- slipView.boardInfons.size()
        me int: boardItemHeight <- 60
        me GuiCoords: RA{posX, posY, 250, boardItemHeight*numboards}
        dr.addC(cmdSetColor, popupBkgnd); dr.addRA(cmdDrawRect, RA); dr.add1(cmdFill)
        dr.addC(cmdSetColor, titleTextColr); dr.addRA(cmdDrawRect, RA); dr.add1(cmdStroke)
        me int: yCur <- RA.Y
        me int: xCur <- RA.X+10
        me int: count <- 0
        withEach board in slipView.boardInfons{
            our POV: propertiesInf <- fetchField(board, "properties")
            our POV: titleInf      <- fetchField(propertiesInf.pItem, "title")
            me string: title       <- titleInf.pItem.fetchString()

            me GuiCoords: ItmRA{posX, yCur, 250, boardItemHeight}
            dr.addC(cmdSetColor, titleTextColr); dr.addRA(cmdDrawRect, ItmRA); dr.add1(cmdStroke)
            dr.addC(cmdSetColor, titleTextColr)
            dr.addTF(cmdRenderText, xCur, yCur+(boardItemHeight/2)+(styler.titleFont.height/2-9), title, styler.titleFont)

            our ProactEvent:: brdItmEvent;
            brdItmEvent.setTrigger(tPrimaryClick, ItmRA); brdItmEvent.setGUI_Store_Int1(slipView.myInfon.mySymbol()+"/crntBorad", count)
            registerEvent(brdItmEvent)
            yCur <+- boardItemHeight
            count <+- 1
        }
    }

    void: drawDashboard(our dashDrawing: dr, our infon: board, me GUI_Scalar:posX, me GUI_Scalar:posY, me GUI_Scalar: width, me GUI_Scalar:height) <- {
        me string: itemID      <- board.mySymbol()
        our POV: propertiesInf <- fetchField(board, "properties")
        our POV: titleInf      <- fetchField(propertiesInf.pItem, "title")
        our POV: backgroundInf <- fetchField(propertiesInf.pItem, "backgroundpic")
        our POV: dataInf       <- fetchField(board, "data")
        me string: title       <- titleInf.pItem.fetchString()
        me string: background  <- backgroundInf.pItem.fetchString()
me bool: modalPoped <- modelMgr.getBool(itemID+"modalPoped", false)
        me bool: boardListPopped <- modelMgr.getBool(itemID+"boardListPopped", false)

        if(background!=""){dr.addT(cmdDrawBkgndImage, background)}
        dr.addC(cmdSetColor, surfaceBkgnd)
        me GuiCoords: RA{posX,posY,width,50}; dr.addRA(cmdDrawRect, RA)
        dr.add1(cmdFill)
        dr.addC(cmdSetColor, titleTextColr)
        me string: brdTitleText <- "Board: "+title
        me deltaSize: DSize <- getTextSize(brdTitleText, styler.titleFont)
        dr.addTF(cmdRenderTextCentered, windowW/2, 33, brdTitleText, styler.titleFont)
        me GuiCoords:open_RA{width/2-(DSize.width/2+33), 6, 36, 36}
        drawCircleButton(dr, open_RA.X, open_RA.Y, open_RA.W/2, 4, ">", board.mySymbol()+":open")
        our ProactEvent:: brdMenuEvent;
        brdMenuEvent.setTrigger(tPrimaryClick, open_RA); brdMenuEvent.setGUI_Store_Int1(itemID+"boardListPopped", 1)
        registerEvent(brdMenuEvent)

        me GuiCoords:RA2{20, 11, 28, 28}
        drawCircleButton(dr, RA2.X, RA2.Y, RA2.W/2, 4, "menu", board.mySymbol()+":Menu")
        our ProactEvent:: addMenuEvent;
        addMenuEvent.setTrigger(tPrimaryClick, RA2); addMenuEvent.setGUI_Store_Int1(itemID+"modalPoped", 1)
        registerEvent(addMenuEvent)

        me GuiCoords:RA3{width-50, 7, 36, 36}
        drawCircleButton(dr, RA3.X, RA3.Y, RA3.W/2, 5, "+", board.mySymbol()+":AddItem")
        our ProactEvent:: addListEvent3;
        addListEvent3.setTrigger(tPrimaryClick, RA3); addListEvent3.setInfonEvent(eAddInfon, dataInf, NULL)
        registerEvent(addListEvent3)

        our POV: pov <- dataInf.pItem.value.items.begin()
        while(pov){
            me GUI_Scalar: xPos <- 15
            me GUI_Scalar: yPos <- 75
            our infon: infn <- pov.pItem
            me GUI_Scalar: returnWidth
            me GUI_Scalar: returnHeight
            drawUnsizedElement(dr, infn, xPos, yPos, returnWidth, returnHeight, "")
            pov <- pov.next
        }

        if(boardListPopped){
            our dashDrawing:: boardPopup
            drawBoardMenu(boardPopup, open_RA.X, open_RA.Y+36)
            slipView.addPopup(boardPopup)

            our ProactEvent:: closeBrdMenu
            me GuiCoords:null_RA{-1,0,0,0}
            closeBrdMenu.setTrigger(tPrimaryClick, null_RA) // Any click closes the menu
            closeBrdMenu.setGUI_Store_Int1(itemID+"boardListPopped", 0)
            registerBroadcastEvent(closeBrdMenu)
        }

        if(modalPoped){
            our ProactEvent:: YesBtnEvent;
            YesBtnEvent.setGUI_Store_Int1(itemID+"modalPoped", 0)

            our dashDrawing:: menuPopup
            drawMessageDialog(menuPopup, "Yes|WTF?", "Can you read this text?\nSubtitle", windowW/2-125, windowH/2-75,250,150, YesBtnEvent, NULL)
            registerEvent(YesBtnEvent)
            slipView.addPopup(menuPopup)
        }
    }
}

struct SlipView: inherits=ProactiveGUIWidget{
    our infon: myInfon
    me int: crntBoardIdx

    me List<our infon>: boardInfons
    our dashDrawing: popup_dr

    void: draw(their GUI_ctxt: cr) <- {
        popup_dr<-NULL
        proactiveGUI.presenter.reset()
        setCrntBoard(proactiveGUI.presenter.modelMgr.getInt64(myInfon.mySymbol()+"/crntBorad", 1))
        setwindowMetrics()
        our dashDrawing:: dr
        proactiveGUI.presenter.drawDashboard(dr, boardInfons[crntBoardIdx], 0,0,windowW,windowH)
        dr.render(cr)
        if(popup_dr!=NULL){
            popup_dr.render(cr)
        }

    }

    void: addPopup(our dashDrawing: popup) <- {
        popup_dr <- popup
    }

    void: setCrntBoard(me int: boardIdx) <-{
        crntBoardIdx <- boardIdx
    }
    bool: loadData(our infon: theInfon) <- {
        myInfon<-theInfon;
        our POV: projectsInf   <- myInfon.fetchField("projects");             if(projectsInf==NULL){log("extract projectsInf = NULL"); return(true)}
        our POV: propertiesInf <- projectsInf.pItem.fetchField("properties"); if(propertiesInf==NULL){log("extract propertiesInf = NULL"); return(true)}
        our POV: titleInf      <- propertiesInf.pItem.fetchField("title");    if(titleInf==NULL){log("extract titleInf = NULL"); return(true)}
            title      <- titleInf.pItem.fetchString()
        our POV: dataInf       <- projectsInf.pItem.fetchField("data")

        withEach infn in dataInf.pItem.value.items{
            if(infn.type!=NULL and infn.type.asGiven=="boardelement"){
                boardInfons.append(infn)
            }
        }
        setCrntBoard(proactiveGUI.presenter.modelMgr.getInt64(myInfon.mySymbol()+"/crntBorad", 1)) // Default to last board for now
        return(false) // No errors
    }
}

struct GLOBAL{
    me ProteusCore: CORE
    me ProactiveGUI: proactiveGUI
    me bool: isFirstRun
    their GUI_canvas: drawing_area
    their SlipView: slipView
}

struct APP{
    me bool: loadAndParseSettingsAndData() <- {
        me string: worldFileName <- "user.pr"
        CORE.init(worldFileName, false)
        if(CORE.WORLD==NULL){
            // TODO: Show system pop-up explaining why we are exiting. Waiting for popup support in GUI_toolkit
            print(CORE.errorMesg, "\n")
            exit(1)
        }
        return(true)
    }

    me void: createAppArea(me GUI_Frame: frame) <- {
        Allocate(slipView)
        drawing_area  <- slipView.initProactiveGUI()
        slipView.loadData(CORE.WORLD)
        addToContainerAndExpand (frame, drawing_area)
    }
}
