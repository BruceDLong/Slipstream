// Slipstream.dog

LinuxBuild: Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';
//SwingBuild: Platform='Java' CPU='JavaVM' Lang='Java' optimize='speed';
//AndroidBuild: Platform='Android' CPU='JavaVM' Lang='Java' optimize='power';
//iPhoneBuild: Platform='IOS' CPU='amd64' Lang='Swift' optimize='speed';

Title = "The Slipstream Browser"
FileName = "Slipstream"
Version = "1.0"
CopyrightMesg = "Copyright 2020-2021 Bruce Long; All rights reserved."
Authors = "Bruce Long"
Description = "The Slipstream Browser"
ProgramOrLibrary = "program"

featuresNeeded = [GUI_ToolKit, Dashboard, Proteus]

LicenseText = `All rights reserved.`

runCode=`
    logMgr.init(OFile)
    thisApp.loadAndParseSettingsAndData()
    isFirstRun<-true
`
////////////   A p p l i c a t i o n   a n d   G l o b a l s

mainStyle = {
    colors = {
    }
    fontNames = {
    }
    fontSizes = {
        fontSizeSmall     = 8
    }
}


do makeStyler(mainStyle)
do makeGUI(GUI_Spec)

struct GLOBAL{
    me int: vertSepSmall   <- 5
    me int: vertSepMed     <- 30
    me int: vertListWidth  <- 200
    me int: headerHeight <- 25
    me int: horizListOPad  <- 5
    me int: Yborder <- 3
    me int: VListHeaderHeight <- 56

    me int: buttonWidth  <-55
    me int: buttonHeight <-22

    me cdColor: buttonBright <- cdColor(255,255,255,255)
    me cdColor: buttonNormal <- cdColor(200,200,200,200)
    me cdColor: surfaceBkgnd <- cdColor(20,20,20,200)
    me cdColor: titleTextColr<- cdColor(200,200,200,225)
    me cdColor: taskCardColor<- cdColor(240,245,240,245)
    me cdColor: cardTextColr <- cdColor(20,30,20,200)
    me cdColor: footerBoxColr<- cdColor(80,80,80,200)
}

struct labelButton: inherits=dash{
    void: init(me string: label) <- {
        title<-label
        width <- buttonWidth; height <- buttonHeight
    }
    me void: draw(their GUI_ctxt: cr) <- {
        if(mouseIsOver){cr.setColor(buttonBright)}else{cr.setColor(titleTextColr)}
        cr.rectangle(posX, posY,width,height)
        cr.fillNow()
        if(mouseIsOver){cr.setColor(footerBoxColr)}else{cr.setColor(cardTextColr)}
        renderTextCentered(cr, title, styler.smallFont, posX+width/2, posY+(height/2)+(styler.smallFont.height/2-2))
        cr.fillNow()
    }
    me bool: primaryUp(their GUI_ButtonEvent: event) <- {
        if (!isTouchingMe(event.x, event.y)) {return(false)}
        getDashBrdMngr().closePopup()
        return(true)
    }
    void: mouseEnter(their GUI_MotionEvent: event) <- {requestRedraw()}
    void: mouseExit(their GUI_MotionEvent: event)  <- {requestRedraw()}
}

struct mesgPopup: inherits=Dashboard{
    me string: result
    me string: mesg
    me List<string>: buttons
    me string: buttonList  // 'ok|', 'ok|cancel|'

    void: init(me string: buttonList, me string: Mesg, me int: W, me int: H) <- {
        result <- ""
        mesg <- Mesg
        width<-W; height<-H;
        me string: btnLabel <- ""
        withEach pos in RANGE(0..buttonList.size()){
            me char: ch<-buttonList[pos]
            if(ch=="|"){buttons.pushLast(btnLabel); btnLabel <- ""}
            else{btnLabel <+- ch}
        }
        me int: numBtns <- buttons.size()
        withEach label in buttons{
            our labelButton:: lBtn; lBtn.init(label)
            lBtn.dashParent <- self
            addChild(lBtn)
        }
    }
    void: setPos(me GUI_Scalar:x, me GUI_Scalar:y, me GUI_Scalar: extCursor) <- {
        posIsSet <- true
        posX <- x; posY <- y; extC <- extCursor
        me int: numBtns <- buttons.size()
        me int: count <- 0
        withEach btn in dashChildren{
            btn.setPos(posX + width/numBtns*count+(width/numBtns/2) - buttonWidth/2, posY+height-(buttonHeight+5), 0)
            count <+- 1
        }
    }
    void: draw(their GUI_ctxt: cr) <- {
        cr.setColor(surfaceBkgnd)
        roundedRectangle(cr, posX, posY, width, height, 13)
        cr.fillNow()

        cr.setColor(footerBoxColr)
        renderText(cr, mesg, styler.defaultFont, posX+5, posY+((height-(buttonHeight+5))/2)+(styler.defaultFont.height/2-2))
        cr.fillNow()

        baseDraw(cr)
    }
}

struct viewStyles:inherits=<mode[vsDefault, vsX_stack, vsY_stack, vsZ_stack, vsPlotGraph, vsDataView, vsString, vsNumber, vsDate]> {}

struct EventTrigger:inherits=<mode[tPrimaryClick, tSecondaryClick, tPrimaryUp, tPrimaryDn, tSecondaryUp, tSecondaryDn,
                                   tMouseMove, tMouseEnter, tMouseExit, tMouseHover, tKeyPress, tTimer
                                  ]> {}

struct EventType:inherits=<mode[eNullEvent, eNormalize, eAddInfon, eDeleteInfon, eEditString, eEditInt, eEditByType,
                                eMoveInfonInList, eMoveInfonToList,
                                eGUI_SetXY, eGUI_SetColor, eGUI_SetDragMode, eGUI_SetTimer, eGUI_PopupModal, eGUI_CloseModal, eGUI_SetViewMode
                               ]> {}

struct ProactEvent{
    me EventTrigger: Trigger
    me GUI_Scalar: X
    me GUI_Scalar: Y
    me GUI_Scalar: W
    me GUI_Scalar: H
    me EventType: eventType
    me string: text
    our infon: inf
    our infon: toInfon
    me GUI_Scalar: arg1
    me GUI_Scalar: arg2
    me GUI_Scalar: arg3
    me GUI_Scalar: arg4

    void: setTrigger(me EventTrigger: trigger, me GUI_Scalar: posX, me GUI_Scalar: posY, me GUI_Scalar: w, me GUI_Scalar: h) <- {
        Trigger<-trigger; X<-posX; Y<-posY; W<-w; H<-h;
    }
    void: setInfonEvent(me EventType: evntType, our infon:infon1, our infon:infon2) <- {eventType<-evntType; inf<-infon1; toInfon<-infon2;}
    void: setNormalizeEvent(me EventType: evntType, me string: query) <- {eventType<-evntType; text<-query;}
    void: setGUI_Event(me EventType: evntType, our infon: target, me GUI_Scalar: a1, me GUI_Scalar: a2, me GUI_Scalar: a3, me GUI_Scalar: a4) <- {
        eventType<-evntType; arg1<-a1; arg2<-a2; arg3<-a3; arg4<-a4;
    }
}

struct Presenter{
    me List<our ProactEvent>: eventRegistry

    void: registerEvent(our ProactEvent: event) <- {eventRegistry.append(event)}
    void: clearEvents() <- {eventRegistry.clear()}

    void: drawCircleButton(our dashDrawing: dr, me GUI_Scalar: posX, me GUI_Scalar: posY, me GUI_Scalar: radius, me GUI_Scalar: lineWidth, me string: symbol) <- {
        me GUI_Scalar: stickLen <- radius/3
        me cdColor: buttonColor<-buttonNormal
        //if(mouseIsOver){buttonColor<-buttonBright} else {buttonColor<-buttonNormal}
        dr.addC(cmdSetColor, buttonColor)
        dr.add1(cmdRoundLineCap)
        dr.add2(cmdSetLineWidth, lineWidth)
       // cr.circle(posX + radius, posY + radius, radius)
        if (symbol=="+") {
            dr.addXY(cmdMoveTo, posX + radius, posY + radius/4)
            dr.addXY(cmdLineTo, posX + radius, posY + 7*radius/4)
            dr.addXY(cmdMoveTo, posX + radius/4, posY + radius)
            dr.addXY(cmdLineTo, posX + 7*radius/4, posY + radius)
        }
        else if (symbol=="-") {
            dr.addXY(cmdMoveTo, posX + radius/4, posY + radius)
            dr.addXY(cmdLineTo, posX + 7*radius/4, posY + radius)
        }
        else if (symbol=="<") {
            dr.addXY(cmdMoveTo, posX + radius, posY + radius - stickLen * sqrt(2.0))
            dr.addXY(cmdLineTo, posX + radius - stickLen * sqrt(2), posY + radius)
            dr.addXY(cmdMoveTo, posX + radius, posY + radius + stickLen * sqrt(2.0))
        }
        else if (symbol==">") {
            dr.addXY(cmdMoveTo, posX + radius, posY + radius - stickLen * sqrt(2.0))
            dr.addXY(cmdLineTo, posX + radius + stickLen * sqrt(2), posY + radius)
            dr.addXY(cmdLineTo, posX + radius, posY + radius + stickLen * sqrt(2.0))
        }
        else if (symbol=="v") {
            dr.addXY(cmdMoveTo, posX  - stickLen * sqrt(2.0), posY )
            dr.addXY(cmdLineTo, posX, posY + radius)
            dr.addXY(cmdLineTo, posX  + stickLen * sqrt(2.0), posY)
        }
        else if (symbol=="menu") {
            dr.addXY(cmdMoveTo, posX + radius/4, posY + radius)
            dr.addXY(cmdLineTo, posX + 7*radius/4, posY + radius)

            dr.addXY(cmdMoveTo, posX + radius/4, posY + radius/4)
            dr.addXY(cmdLineTo, posX + 7*radius/4, posY + radius/4)

            dr.addXY(cmdMoveTo, posX + radius/4, posY + 7*radius/4)
            dr.addXY(cmdLineTo, posX + 7*radius/4, posY + 7*radius/4)
        }
        dr.add1(cmdStroke)
        dr.add1(cmdEdgedLineCap)
    }

    void: drawUnsizedElement(our dashDrawing: dr, our infon: element, me GUI_Scalar:x, me GUI_Scalar:y, their GUI_Scalar: w, their GUI_Scalar:h) <- {
        our infon: propertiesInf <- element.fetchField("properties");          if(propertiesInf==NULL){log("extract propertiesInf = NULL"); return()}
        our infon: titleInf      <- propertiesInf.fetchField("title");         if(titleInf==NULL){log("extract titleInf = NULL"); return()}
        me string: title         <- titleInf.fetchString()
        our infon: dataInf       <- element.fetchField("data"); if(dataInf==NULL){log("extract dataInf = NULL"); return()}

        //me mode[xStack, yStack, zStack, stringItem, integerItem, decimalItem]: viewStyle
        me viewStyles: viewStyle
        if(element.type.asGiven=="kanban"){ viewStyle <- vsX_stack}
        else if(element.type.asGiven=="tasklist"){ viewStyle <- vsY_stack}
        log("INFON_TYPE:"+element.type.asGiven)
        me GUI_Scalar:xPos <- x; me GUI_Scalar:yPos <- y
        me GUI_Scalar:width <- w; me GUI_Scalar:height <- h
        me GUI_Scalar:maxH <- 0
        me GUI_Scalar:H2
        if(viewStyle==vsX_stack){
            // Draw Header

            // Draw Columns
            withEach element in dataInf.value.items{
                dr.addC(cmdSetColor, surfaceBkgnd)

                our dashDrawing:: dr2
                me GUI_Scalar: W2
                drawUnsizedElement(dr2, element, xPos, y+headerHeight, W2, H2)
                maxH <- max(maxH, H2)
                dr.add1(cmdFill)
                dr.addSubDrawing(dr2)
                xPos <+- vertListWidth+8
            }

            // Kanban header
            me GUI_Scalar: X <- x
            w <deep- (xPos-8)-X; h <deep- maxH+headerHeight;
            width<-w
            drawCircleButton(dr, x+width-25, y+headerHeight-21, 8, 3, "+")
            //~ addItemBtn.draw(cr)
            //~ me GUI_Scalar: crntX <- posX
            //~ withEach Dash in items{
                //~ Dash.draw(cr)
            //~}
            dr.addC(cmdSetColor, surfaceBkgnd)
            me RectArea:RA{x, y, width, headerHeight-2}; dr.addRAA(cmdRoundTopRect, RA, 15)
            dr.add1(cmdFill)
            dr.addC(cmdSetColor, titleTextColr)
            dr.addTF(cmdRenderTextCentered, x+width/2, y+(headerHeight/2)+(styler.smallFont.height/2-3), title, styler.smallFont)
        } else if(viewStyle==vsY_stack){
            dr.addC(cmdSetColor, surfaceBkgnd)
            me RectArea:RA{xPos, y, vertListWidth, 0}
            our Drawel: boxDR <- dr.addRAA(cmdRoundTopRect, RA, 15) // Background for lists
            dr.add1(cmdFill)

            // Column Header
            dr.addC(cmdSetColor, titleTextColr)
            dr.addTF(cmdRenderTextCentered, x+(vertListWidth/2), y+(VListHeaderHeight/2)+(styler.titleFont.height/2-5), title, styler.titleFont)

            // Draw the list body
            yPos <- y+VListHeaderHeight
            withEach element in dataInf.value.items{
                dr.addC(cmdSetColor, surfaceBkgnd)
                our dashDrawing:: dr2
                me GUI_Scalar: W2
                drawUnsizedElement(dr2, element, x+5, yPos, W2, H2)
                dr.addSubDrawing(dr2)
                maxH <- max(maxH, H2)
                yPos <+- H2+5
            }

            // Draw the footer
            me int: footerHeight <- 27
            dr.addC(cmdSetColor, footerBoxColr)
            me RectArea:RAf{x+5, yPos, vertListWidth-10, footerHeight-4}
            dr.addRAA(cmdRoundBotRect, RAf, 15)
            dr.add1(cmdFill)
            drawCircleButton(dr, x+10, yPos+H2-20, 8, 3, "menu")
            drawCircleButton(dr, x+vertListWidth-23, yPos+H2-20, 8, 3, "+")
            yPos <+- footerHeight

            boxDR.h<-yPos-y
        } else if(element.type.asGiven=="task"){
            H2 <- styler.smallFont.height+ Yborder*2
            h <deep- H2
            width  <- vertListWidth-5*2

            dr.addC(cmdSetColor, taskCardColor)
            me RectArea:RA{x, y, width, H2}
            dr.addRAA(cmdRoundRect, RA, 13)
            dr.add1(cmdFill)

            dr.addC(cmdSetColor, cardTextColr)
            dr.addTF(cmdRenderText, x+5, y+(H2/2)+(styler.smallFont.height/2-2), title, styler.smallFont)
        }
    }

    void: drawDashboard(our dashDrawing: dr, our infon: board, me GUI_Scalar:x, me GUI_Scalar:y, me GUI_Scalar: w, me GUI_Scalar:h) <- {
        our infon: propertiesInf <- board.fetchField("properties");            if(propertiesInf==NULL){log("extract propertiesInf = NULL"); return()}
        our infon: titleInf      <- propertiesInf.fetchField("title");         if(titleInf==NULL){log("extract titleInf = NULL"); return()}
        our infon: backgroundInf <- propertiesInf.fetchField("backgroundpic"); if(backgroundInf==NULL){log("extract backgroundInf = NULL"); return()}
        me string: title      <- titleInf.fetchString()
        me string: background <- backgroundInf.fetchString()
        our infon: dataInf       <- board.fetchField("data"); if(dataInf==NULL){log("extract dataInf = NULL"); return()}

        if(background!=""){dr.addT(cmdDrawBkgndImage, background)}
        dr.addC(cmdSetColor, surfaceBkgnd)
        me RectArea: RA{0,0,w,50}; dr.addRA(cmdDrawRect, RA)
        dr.add1(cmdFill)
        dr.addC(cmdSetColor, titleTextColr)
        me string: brdTitleText <- "Board: "+title
        me deltaSize: DSize <- getTextSize(brdTitleText, styler.titleFont)
        dr.addTF(cmdRenderTextCentered, windowW/2, 33, brdTitleText, styler.titleFont)
        drawCircleButton(dr, w/2-(DSize.width/2+33), 6, 18, 4, ">")

        drawCircleButton(dr, 20, 11, 14, 4, "menu")
        drawCircleButton(dr, w-50, 7, 18, 5, "+")
        withEach infn in dataInf.value.items{
            drawUnsizedElement(dr, infn, 20, 70, w, h)
        }
    }
}

struct GLOBAL{
    me Presenter: presenter
}

struct SlipView: inherits=DashboardWidget{
    our infon: myInfon
    me int: crntBoardIdx
    //their appComponentGUI: parentGuiMgr

    me List<our infon>: boardInfons

    void: draw(their GUI_ctxt: cr) <- {
        setwindowMetrics()
        our dashDrawing:: dr
        presenter.drawDashboard(dr, boardInfons[crntBoardIdx], 0,0,windowW,windowH)
        dr.render(cr)

    }
    void: setCrntBoard(me int: boardIdx) <-{
        crntBoardIdx <- boardIdx
    }
    bool: loadData(our infon: theInfon) <- {
        myInfon<-theInfon;
        our infon: projectsInf   <- myInfon.fetchField("projects");       if(projectsInf==NULL){log("extract projectsInf = NULL"); return(true)}
        our infon: propertiesInf <- projectsInf.fetchField("properties"); if(propertiesInf==NULL){log("extract propertiesInf = NULL"); return(true)}
        our infon: titleInf      <- propertiesInf.fetchField("title");    if(titleInf==NULL){log("extract titleInf = NULL"); return(true)}
            title      <- titleInf.fetchString()
        our infon: dataInf       <- projectsInf.fetchField("data")

        withEach infn in dataInf.value.items{
            if(infn.type!=NULL and infn.type.asGiven=="boardelement"){
                boardInfons.append(infn)
            }
        }
        setCrntBoard(boardInfons.size()-1) // Default to last board for now
        return(false) // No errors
    }

    me bool: secondaryClick(their GUI_ButtonEvent: event) <- {
        if(showModalPopUp){return(popUp.secondaryClick(event))}
        our mesgPopup:: ePop
        ePop.dashParent <- self
        ePop.init("ok|cancel|", "Do not Right Click!", 200, 120)
        getDashBrdMngr().activateModalPopup(ePop)
        return(true)
    }

    //~ me int:  getValue() <- {return(0)}
    //~ me void: setValue(me int: val) <- {}
    //~ void: onChanged()  <- {parentGuiMgr.onChanged()}
}


struct GLOBAL{
    me ProteusCore: CORE
    me bool: isFirstRun
    their GUI_canvas: drawing_area
    their SlipView: slipView
}

struct APP{
    me bool: loadAndParseSettingsAndData() <- {
        me string: worldFileName <- "user.pr"
        CORE.init(worldFileName, false)
        if(CORE.WORLD==NULL){
            //~ our mesgPopup: errorPopup
            //~ errorPopup.init("ok|cancel|", CORE.errorMesg)
            //~ popUp <- errorPopup
            print(CORE.errorMesg, "\n")
            exit(1)
        }
        return(true)
    }

    me void: createAppArea(me GUI_Frame: frame) <- {
        Allocate(slipView)
        drawing_area  <- slipView.init("")
        slipView.loadData(CORE.WORLD)
        addToContainerAndExpand (frame, drawing_area)
    }
}
