// Slipstream.dog

LinuxBuild: Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';
//SwingBuild: Platform='Java' CPU='JavaVM' Lang='Java' optimize='speed';
//AndroidBuild: Platform='Android' CPU='JavaVM' Lang='Java' optimize='power';
//iPhoneBuild: Platform='IOS' CPU='amd64' Lang='Swift' optimize='speed';

Title = "Slipstream"
FileName = "Slipstream"
Version = "1.0"
CopyrightMesg = "Public Domain"
Authors = "Bruce Long"
Description = "The Slipstream App"
ProgramOrLibrary = "program"

featuresNeeded = [GameToolkit, Logger, Proteus, BigNumbers]

LicenseText = `All rights reserved.`

runCode=`
    initializeGraphics(false)
    setUpApp()
    gameLooper.play(1, 40)
    deinitGraphics()
`
////////////   A p p l i c a t i o n   a n d   G l o b a l s

struct ProtDraw{
    our infon: item
    flag: open

    me int: w
    me int: height
    me int: draw(their GUI_ctxt: cr, our infon: infn, me int: x, me int: y, me int: indent) <- {
	me int: curY <- y
	me int: curX <- x +indent * 2
	cr.setColor(Styler.White)
	our fontSpec:: textFont {"Ariel", 12, 0}
	me deltaSize:  size
	if(infn.value.fType == NUM){
	    size <- renderText(cr, toString(infn.value.num), textFont, curX, curY)
	}else if(infn.value.fType == STR){
	    size <- renderText(cr, infn.value.str, textFont, curX, curY)
	}else if(infn.value.fType == LST){
	    withEach i in infn.value.items{
		curY <+- draw(cr, i, curX, curY, indent+1)
		if(curY > height){break()}
	    }
	}
	return(size.height)
    }
}

struct SlipstreamScreen: inherits=GameMode{
    me int: textY

    void: update() <- {}
    void: draw(their GUI_ctxt: cr, me double: interpolation) <- {
	protDraw.height <- screenHeight
	protDraw.draw(cr, protDraw.item, 0, 50, 5)
        cr.strokeNow()
        window.requestRedraw()
    }
    void: pause() <- {}
    void: resume() <- {}
    void: keyDownEventHandler(their KeyInfo: event) <- {
        switch (event.sym){
            case SDLK_SPACE:{
		setUpApp()

            }
            case SDLK_ESCAPE:{
                looper.quitGame()
            }
        }
    }
    void: init(our GameLooper: ourLooper) <- {looper <- ourLooper}
    void: deInit() <- {}
}
struct SettingsScreen: inherits=GameMode{
    void: update() <- {}
    void: draw(their GUI_ctxt: cr, me double: interpolation) <- {
        cr.setColor(Styler.White)
        our fontSpec:: textFont {"Ariel", 20, 0}
        renderTextCentered(cr, "PAUSED", textFont, screenWidth/2, 200)
        renderTextCentered(cr, "Press Space to Continue Playing", textFont, screenWidth/2, 300)
	renderTextCentered(cr, "Press Escape to Exit", textFont, screenWidth/2, 400)
        cr.strokeNow()
        window.requestRedraw()
    }
    void: pause() <- {}
    void: resume() <- {}
    void: keyDownEventHandler(their KeyInfo: event) <- {
        switch (event.sym){
            case SDLK_SPACE:{

            }
            case SDLK_ESCAPE:{
		looper.setGameMode(slipstreamScreen)
            }
        }
    }
    void: init(our GameLooper: ourLooper) <- {looper <- ourLooper}
    void: deInit() <- {}
}
struct GLOBAL{
    their GUI_canvas: drawing_area
    me int: fontSize
    our GameLooper:: gameLooper
    our SlipstreamScreen:: slipstreamScreen
    our SettingsScreen:: settingsScreen
    me ProtDraw: protDraw

    void: setUpApp() <- {
	me ProteusCore: CORE
	me string: resourceDir <- "world.pr"
	if(! CORE.init(resourceDir)){logFatalError("Failed to initialize Proteus Core:"+CORE.errorMesg)}
	protDraw.item <- CORE.WORLD
        slipstreamScreen.init(gameLooper)
	settingsScreen.init(gameLooper)
        gameLooper.setGameMode(slipstreamScreen)
    }
    void: toggleFullScreen() <- {
        if(getFullScreenMode()){
            fullScreenModeOff()
        }else{
            fullScreenModeOn()
        }
    }
}

struct APP{
    my GUI: gui
}


