//////////////////  Classes for Slipstream Based Applications
// Slipstream.Lib.dog

//LinuxTestBuild: Platform='Linux' CPU='amd64' Lang='CPP' testMode='makeTests';
LinuxBuild:     Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';

FileName = "slipstream"
Version = "0.1"
CopyrightMesg = "Copyright (c) 2020-<YEAR> Bruce Long"
Authors = "Bruce Long"
Description = "The Slipstream Engine"
ProgramOrLibrary = "program"

featuresNeeded = [Proteus, Logger, Unicode, BigNumbers, Threads, IOBuffer, EarleyParser, Quic] // Crypto, P2P_Manager]

LicenseText = `This file is part of the "Slipstream Development Suite" All Rights Reserved.`

runCode=`
    logMgr.init(OFile)
    log("Slipstream CORE started")
    me SlipstreamCore: CORE
    CommandLineManager.processCmdLine(joinCmdStrings(argc, argv), false);
    CommandLineManager.defineOption("Slip", "topFile", "-f", "--file", "The top-level file to load.")
    me string: topFile <- CommandLineManager.getOption("Slip", "topFile")
    if(topFile==""){topFile <- "world.pr"}
    CORE.run(topFile)
`
struct RepositoryManager{ // Load, track, save, pull, push, pullReq, etc.
}

model BidiConnector{
    me strBuf: inputBuf
    me strBuf: outputBuf
    me int:    statusCode
    me string: statusMesg
    void: init(me string: itemRefStr) <- {}
    bool: pumpInputBuf()  <- {}
    bool: pumpOutputBuf() <- {}
}
struct BidiConnector{}

struct FileConnector: inherits=BidiConnector {
    me FileStream: dataFile
    void: init(me string: itemRefStr) <- {
        me string: fileDir <- getAssetsDir() +"/"+itemRefStr //+"/repos"
        dataFile.open(fileDir)
        if (dataFile.failure()){logFatalError("Failed to open file: " + fileDir + "\n")}
    }
    bool: pumpInputBuf()  <- {
        if(!dataFile.EOF()){
            me string: line <- dataFile.getLine()
            inputBuf.putStr(line)
            return(true)
        }
        return(false)
    }
    bool: pumpOutputBuf() <- {return(false)}
}
struct ClipConnector: inherits=BidiConnector {}
struct UserConnector: inherits=BidiConnector {}
struct IPFSConnector: inherits=BidiConnector {}
struct IPNSConnector: inherits=BidiConnector {}
struct RepoConnector: inherits=BidiConnector {}     // Connector to a RepositoryManager instance.
struct GUI_Connector: inherits=BidiConnector {}     // Kbd, mouse/touchScn, screen, clipboard, etc.
struct MediaConnector:inherits=BidiConnector {}     // Microphones, audioOut, videoSource
struct AgentConnector:inherits=BidiConnector {      // Connect to other agents
    me QuicEngine_Client: clientQuicEngine
    void: init(me string: specString) <- {
        me int: colonPos <- specString.find(":")
        me string: connectionTypeStr <- specString.subStr(0, colonPos)
        me string: connectionIDStr   <- specString.subStr(colonPos+1)
        colonPos <- connectionIDStr.find(":")
        me string: fileToFetch <- connectionIDStr.subStr(0, colonPos)
        me string: IPAddr <- connectionIDStr
        me string: portNumStr <- connectionIDStr
        clientQuicEngine.inputBuf <- inputBuf
        clientQuicEngine.init("xferText.pr", false, IPAddr, stoi(portNumStr))
    }
    bool: pumpInputBuf()  <- {
        //~ if(!dataFile.EOF()){
            //~ me string: line <- dataFile.getLine()
            //~ inputBuf.putStr(line)
            //~ return(true)
        //~ }
        return(false)
    }
    bool: pumpOutputBuf() <- {return(false)}
}
struct SensorConnector  : inherits=BidiConnector {}
struct RobotConnector   : inherits=BidiConnector {}
struct InternetConnector: inherits=BidiConnector {}
struct PhoneConnector   : inherits=BidiConnector {} // Services offered by phones


//////////////////////////////////////////////////////////////////////

struct InfonStream{ // BidiConnector -> Parse -> Extract -> Normalize
    our BidiConnector: source
    their Agent: parentAgent
    our EParser: parser
    me Threaded_infonParseAndExtractor: parseAndExtractor
    me ThreadedNormalizer: threadedNormalizer

    void: init(our BidiConnector: connector, their Agent: agent, our EParser: eParser) <- {
        source <- connector
        parentAgent <- agent
        parser <- eParser
    }
    void: start() <- {
        our infon:: returnInfon  log("AT-A")
        threadedNormalizer.init(parentAgent, returnInfon)
        threadedNormalizer.start()   log("AT-B")
        parseAndExtractor.start(parser, source.inputBuf, returnInfon)
        while(source.pumpInputBuf()){}
        source.inputBuf.close()   log("AT-C")
        threadedNormalizer.waitForExit()  log("AT-D")
parseAndExtractor.waitForThreadsToExit()  log("AT-E")
        log("Result:"+toString(returnInfon))
    }
    void: requestFinish() <- {}
}

struct ConnectionManager{ // Manage connections to a Proteus Agent
    their Agent: agent
    me List<our InfonStream>: connections
    our EParser: parser
    void: init(their Agent: agnt) <- {
        agent <- agnt
        connections.clear()
        Allocate(parser)
        parser.populateGrammar()
    }
    me bool: startNewConnection(me string: specString) <- {
        our BidiConnector: connector <- makeBidiConnector(specString)
        our InfonStream:: iStream
        iStream.init(connector, agent, parser)
        connections.append(iStream)
        iStream.start()
        return(true)
    }
    our BidiConnector: makeBidiConnector(me string: specString)<-{ // connector factory
        me int: colonPos <- specString.find(":")
        me string: connectionTypeStr <- specString.subStr(0, colonPos)
        me string: connectionIDStr   <- specString.subStr(colonPos+1)
        if     (connectionTypeStr=="file"){our FileConnector:: retval; retval.init(connectionIDStr); return(retval)}
        else if(connectionTypeStr=="repo"){our RepoConnector:: retval; retval.init(connectionIDStr); return(retval)}
        else if(connectionTypeStr=="user"){our UserConnector:: retval; retval.init(connectionIDStr); return(retval)}
        else if(connectionTypeStr=="ipfs"){our IPFSConnector:: retval; retval.init(connectionIDStr); return(retval)}
        else if(connectionTypeStr=="ipns"){our IPNSConnector:: retval; retval.init(connectionIDStr); return(retval)}
        else if(connectionTypeStr=="agnt"){our AgentConnector:: retval; retval.init(connectionIDStr); return(retval)}
        else {}
    }
}

struct SlipstreamCore{ // Create and manage a slipstream node
    me Agent: agent
    me string: masterFile
    me ConnectionManager: connectionMgr
    me string: statusMsg
    me bool: stillIdling
    void: initCoreServices()<-{
        // Init P2P connections and DHTs
        // Etc.
    }
    void: init(me string: topFile) <- {
        streamingNormMode <- true
        statusMsg <- ""  // Empty == OK
        masterFile <- "file:"+topFile
     //   masterFile <- "quic:getFile:"+topFile
log("Masterfile:"+ masterFile)
        initCoreServices()
        our Map<string, string>:: settings
        agent.init2(settings)
        connectionMgr.init(agent)
        stillIdling <- false
    }
    void: start() <- {
log("LOCALE:"+agent.getLocaleBaseName())
        stillIdling <- true
        connectionMgr.startNewConnection(masterFile)


        //agent.extendAndNorm(agent.world, "file:"+topFile)
log("WORLD:"+toString(agent.world))
    }
    void: idle()<-{
        while(stillIdling){
            // process events if needed
            sleep(10)
        }
    }
    void: stopIdling()<-{stillIdling <- false}
    void: shutdown()<-{} // TODO: Ask all streams to quit then wait for them. Dealloc anything

    void: run(me string: topFile) <- {
        init(topFile)
        start()
        sleep(1000)
       // idle()
        shutdown()
    }
}
