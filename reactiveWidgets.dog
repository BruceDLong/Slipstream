// Some Reactive Widgets

struct GLOBAL{

    me fontSpec: editFont
    me Map<int32, int>: charWidths
    me int: getCharWidthX1024(me int32: chr, me fontSpec: font) <- {
        itr Map<int32, int>: chrWidthItr <- charWidths.find(chr)
        if(chrWidthItr!=charWidths.end()){
            return(chrWidthItr.val)
        }
        me string: text; text <+- chr
        me deltaSize: ds <- getTextSizeX1024(text, font)
        me int: width <- ds.width
        charWidths[chr] <- width
        return(width)
    }
}

struct TextEditBox: inherits=ReactiveControl{
    me bool: multiLineMode
    our ParamRec: thisPR
    me string: crntLine
    me int: widthToCur
    me int: charsToCur
    me int: curMax           // Most recent width to cursor
    me bool: overwriteMode   // False = InsertMode

    const int: leftXPad <- 10

    void: setMetrics(our ParamRec: PR) <- {
        me string: text <- PR.sourcePov.pItem.value.str
        me deltaSize: DSize <- getTextSize(text, PR.font)
        PR.posW <- DSize.width + Yborder*2
        PR.posH <- DSize.height + 10*2 // 10 px on top and bottom
    }

    me int: getCharWidth(me int32: chr) <- {return(getCharWidthX1024(chr, thisPR.font)/1024)}

    me int: calcWidthToCursor(me string: line, me int: charsToCur) <- {
        me int: wtc <- 0
        withEach p in RANGE(0..charsToCur){
            wtc <+- getCharWidthX1024(line[p], thisPR.font)
        }
        return(wtc/1024)
    }

    me void: setCursorByWidth(me string: line, me int: maxWidthToCur) <- {
        me int32: wtc <- 0
        me int: p <- 0
        if(line.size()==0){charsToCur<-0; widthToCur<-0; return();}
        withEach count in RANGE(0..line.size()){
            me int: chrWidth <- getCharWidth(line[p])
            if(wtc+(chrWidth/2) >= maxWidthToCur){break()}
            wtc <+- chrWidth
            p <+- 1
        }
        charsToCur<-p
        widthToCur<-wtc
    }

    void: insertChar(me int32: chr) <- {
        if (!overwriteMode){
            me string: S; S <+- chr
            crntLine.insert(charsToCur, S)
            charsToCur <+- 1
            widthToCur <+- getCharWidth(chr)
        } else {} // TODO: Overwrite mode
        curMax<-widthToCur
    }

    void: moveLeft() <- {
        if(charsToCur>0){
            charsToCur <-- 1
            widthToCur <-- getCharWidth(crntLine[charsToCur])
            curMax <- widthToCur
        } /*else if(!isFirstInSet(currentLine)){
            moveUp();
            moveEnd();
        }*/
    }

    void: moveRight() <- {
        if(charsToCur < crntLine.size()){
            widthToCur <+- getCharWidth(crntLine[charsToCur])
            charsToCur <+- 1
            curMax<-widthToCur
        } /*else if(!isLastInSet(currentLine)){
            moveDown()
            moveHome()
        }*/
    }
    void: moveHome() <- {
        charsToCur<-0
        widthToCur<-0
        curMax<-widthToCur
    }
    void: moveEnd() <- {
        charsToCur<-crntLine.size()
        widthToCur<-calcWidthToCursor(crntLine, charsToCur)
        curMax<-widthToCur
    }

    void: doDelete() <- {
        if(charsToCur==crntLine.size()){return()}
        crntLine.erase(charsToCur,1)
        widthToCur <- calcWidthToCursor(crntLine, charsToCur)
        curMax <- widthToCur
    }

    void: backspc() <- {if(charsToCur>0){moveLeft(); doDelete();}}
    void: revert()  <- {
        crntLine <- thisPR.sourcePov.pItem.value.str
        moveEnd()
    }

    void: draw(our dashDrawing: dr, our ParamRec: PR) <- {
        dr.addC(cmdSetColor, styler.White)
        me string: text
        me string: prompt
        if(PR.title!=""){
            prompt<-PR.title
            if(prompt=="NO_PROMPT"){prompt<-""}
        } else if(PR.sourcePov.pItem.type!=NULL){
            prompt <- PR.sourcePov.pItem.type.asGiven+": "
            prompt <- deCamelCase(prompt)
        }
        text <- PR.dataPov.pItem.value.str

        me int: labelY_offset <- 0
        me int: labelX_offset <- 0

        me string: GDR_ID <- PR.dataPov.mySymbol()+"/editBox"
        our GuiDataRec: textBoxGDR <-  proactiveGUI.presenter.modelMgr.fetchGuiData(GDR_ID)

        if(textBoxGDR!=NULL){isActive <- textBoxGDR.isActive}
        else{
            Allocate(textBoxGDR); proactiveGUI.presenter.modelMgr.guiData[GDR_ID]<-textBoxGDR
            if(PR.startActive) {isActive<-1; proactiveGUI.presenter.grabFocus(GDR_ID)} else {isActive<-0}
        }
        if(isActive==0){
            dr.addC(cmdSetColor, cdColor(200,200,200,200))
            me GuiCoords:myCoords{PR.posX, PR.posY, PR.posW, PR.posH}
            dr.addRA(cmdDrawRect, myCoords)
            dr.add1(cmdFill)

            // Draw the label
            if(prompt!=""){
                labelY_offset <- 10
                labelX_offset <- leftXPad
                dr.addC(cmdSetColor, styler.Black)
                dr.addTF(cmdRenderText, PR.posX+labelX_offset/2, PR.posY+PR.posH/2+(styler.smallFont.height/2)-4-8, prompt, styler.smallFont)
                dr.add1(cmdFill)
            }

            // Draw the text
            dr.addC(cmdSetColor, styler.Black)
            dr.addTF(cmdRenderText, PR.posX+labelX_offset, PR.posY+PR.posH/2+(PR.font.height/2)-4+labelY_offset, text, PR.font)
            dr.add1(cmdFill)

            our ProactEvent:: clickEvent;
            clickEvent.setTrigger(tPrimaryClick, myCoords); clickEvent.setGUI_SetActiveFlag(GDR_ID, 1)
            proactiveGUI.presenter.registerEvent(clickEvent)
        } else {
            our TextEditBox: TEBox
            if(prompt!=""){labelX_offset <- leftXPad}
            if(isActive==1){ // This is first time; init GDR
                textBoxGDR.isActive <- 2 // Set 'not first time'
                textBoxGDR.str1 <- prompt
                Allocate(TEBox)
                textBoxGDR.ctrl <- TEBox
                TEBox.thisPR <- PR
                TEBox.crntLine <- text
                TEBox.moveEnd()
            } else {TEBox <- asClass(TextEditBox, textBoxGDR.ctrl)}
            dr.addC(cmdSetColor, cdColor(200,230,200,200))
            me GuiCoords:myCoords{PR.posX, PR.posY, PR.posW, PR.posH}
            dr.addRA(cmdDrawRect, myCoords)
            dr.add1(cmdFill)

            me GUI_Scalar: xPos <- PR.posX+labelX_offset
            me GUI_Scalar: yPos <- PR.posY+PR.posH/2+(PR.font.height/2)-4

            dr.addC(cmdSetColor, styler.Black)
            dr.addTF(cmdRenderText, xPos, yPos, TEBox.crntLine, PR.font)
            dr.add1(cmdFill)

            me GUI_Scalar: cursorPos <- xPos + TEBox.widthToCur
            drawACursor(dr, cursorPos, yPos, PR.font.height)

            our ProactEvent:: clickEvent;
            clickEvent.setTrigger(tPrimaryClick, myCoords); clickEvent.setGUI_CallFunc(ePrimaryClick, GDR_ID)
            proactiveGUI.presenter.registerEvent(clickEvent)
        }
    }
    void: saveBack() <- {
        thisPR.dataPov.pItem.value.str <- crntLine
        isActive<-false
        // If parent exists, sent buffer to it.
        if(thisPR.parentCtrlsData!=NULL){
            thisPR.parentCtrlsData.ctrl.processEntry(crntLine)
        }
    }
    me bool: expandsX()<-{return(true)}
    me bool: expandsY()<-{return(false)}

     me bool: mouseMoved(me GUI_Scalar:posX, me GUI_Scalar:posY) <- {
         return(true)
     }
     me bool: primaryClick(me GUI_Scalar:posX, me GUI_Scalar:posY) <- {
         setCursorByWidth(crntLine, posX-(thisPR.posX+leftXPad))
         print("TEXTEDIT_BOX_CLICK!:",posX-(thisPR.posX+leftXPad), "\n")
         return(true)
     }
     me bool: keyTyped(their GUI_KeyboardEvent: event) <- {
         me int32: cmd <- event.keyval
         if((event.state & CONTROL_MASK) or cmd == 127 or cmd > 255){
             me bool: cmdHandled <- false;
             if(multiLineMode){}  // handle multiline cmds then set cmdHandled<-true
             if(!cmdHandled){
                if(event.state & CONTROL_MASK) {
                    switch(cmd){
                        case KEY_a: {}                            // CTRL-A - Select all
                        case 3: {}                                // CTRL-C - Copy
                        case 22: {}                               // CTRL-V - Paste
                        case KEY_s: {thisPR.sourcePov.pItem.value.str <- crntLine} // CTRL-S - Save back
                        case 23: {}                               // CTRL-W - Toggle word-wrap Mode
                        case 24: {}                               // CTRL-X - Cut
                        case 25: {}                               // CTRL-Y - Redo
                        case 26: {}                               // CTRL-Z - Undo
                    }
                } else {
                    switch(cmd){
                        case KEY_LEFT:      {moveLeft()}
                        case KEY_RIGHT:     {moveRight()}
                        case KEY_HOME:      {moveHome()}
                        case KEY_END:       {moveEnd()}
                        case KEY_DELETE:    {doDelete()}
                        case KEY_RETURN:    {saveBack()}
                        case KP_LEFT:       {moveLeft()}
                        case KP_RIGHT:      {moveRight()}
                        case KP_HOME:       {moveHome()}
                        case KP_END:        {moveEnd()}
                        case KP_DELETE:     {doDelete()}
                        case KP_ENTER:      {saveBack()}
                        case KEY_BACKSPACE: {backspc()}
                        case KEY_ESCAPE:    {revert()}
                    }
                }
             }
         } else {
             insertChar(event.keyval)
        }
         slipView.requestRedraw()
         //print("KEY_PRESS:",event.keyval, " ==>", crntLine, "\n")
         return(true)
    }

    void: INIT() <- {
        widthToCur<-0
        charsToCur<-0
        multiLineMode <- false
    }
}

///////////////////////// TerminalApp
struct TerminalApp: inherits=ReactiveControl{
    our GuiDataRec: GDR
    our InfonStream: iStream
    our ParamRec: thisPR

    void: draw(our dashDrawing: dr, our ParamRec: PR) <- {
        me int: height <- 400
        me int: width  <- 500
        me GuiCoords:RA{PR.posX, PR.posY, width, height}
        dr.addC(cmdSetColor, surfaceBkgnd)
        dr.addRAA(cmdRoundRect, RA, 15)
        dr.add1(cmdFill)

        // Block click-under
        our ProactEvent:: blockEvents;
        blockEvents.setTrigger(tPrimaryClick, RA, PR.topPov); blockEvents.setGUI_Event1(eBlockEvents)
        proactiveGUI.presenter.registerEvent(blockEvents)

        // dragging header
        PR.posW <- width
        PR.posH <- height;

        dr.addC(cmdSetColor, surfaceBkgnd)
        me GuiCoords:HedrRectXYWH{PR.posX, PR.posY, width, headerHeight-2};
        dr.addRAA(cmdRoundTopRect, HedrRectXYWH, 15)
        dr.add1(cmdFill)
        if(PR.screenPos!=NULL){
            our ProactEvent:: dragEvent;
            dragEvent.setTrigger(tDragStart, HedrRectXYWH); dragEvent.setInfonEvent(eGUI_SetXY, PR.xPov, PR.yPov)
            proactiveGUI.presenter.registerEvent(dragEvent)
        }

        // Fetch App Streams
        me string: GDR_ID <- PR.sourcePov.mySymbol()+"/terminalApp"
        our GuiDataRec: termBoxGDR <- proactiveGUI.presenter.modelMgr.fetchGuiData(GDR_ID)
        isActive <- 0
        our TerminalApp: TermApp
        if(termBoxGDR!=NULL){isActive <- termBoxGDR.isActive}
        else{Allocate(termBoxGDR); proactiveGUI.presenter.modelMgr.guiData[GDR_ID]<-termBoxGDR}
        if(isActive==0){ // This is first time; init GDR
            log("DRAW_TERM_INIT()")
            Allocate(TermApp)
            termBoxGDR.isActive <- 1 // Set 'not first time'
            termBoxGDR.ctrl <- TermApp
            TermApp.iStream <- CORE.connectionMgr.user.appendAnInfonAndLoad(CORE.connectionMgr, "drct:///")
            TermApp.thisPR  <- PR
            TermApp.GDR     <- termBoxGDR
            our DrctConnector: DConn <- asClass(DrctConnector, TermApp.iStream.source)
            DConn.termToConnect <- TermApp
        } else {TermApp <- asClass(TerminalApp, termBoxGDR.ctrl)}

        // Calc which entries appear in window
        me int64: editWidth   <- width
        me int64: lineHeight  <- 16
        me int64: heightACC <- lineHeight
        their PovList: dataItems <- PR.dataPov.pItem.value.items
        if(dataItems.isEmpty()){
            our POV: newPov <- PR.dataPov.tryAddingTentativeChild()
            newPov.pItem.infCharPos <- 0
        }
        our POV: pov <- dataItems.back()
        while(pov){
            our POV: propertiesInf <- fetchField(pov, "properties")
            //our POV: dataInf       <- fetchField(pov, "data")
            me string: sourceID   <- fetchStringField(fetchField(propertiesInf, "sourceid"))
            me int64: entryWidth  <- fetchIntField(fetchField(propertiesInf, "width"))
            me int64: numLines    <- entryWidth/editWidth+1
            heightACC   <+- lineHeight * numLines
            //me string: entryText  <- fetchStringField(dataInf)
            if(heightACC>=height){break()}
            pov <- pov.prev
        }
        if(pov==NULL){pov <- dataItems.front()}
        // Draw contents
        me int: xCur <- PR.posX+5
        me int: yCur <- PR.posY+headerHeight
        me int: crntLineNum <- 0
        while(pov!=NULL and pov!==dataItems.back()){
            our POV: propertiesInf <- fetchField(pov, "properties")
            our POV: dataInf       <- fetchField(pov, "data")
            me string: sourceID   <- fetchStringField(fetchField(propertiesInf, "sourceid"))
            me int64: entryWidth  <- fetchIntField(fetchField(propertiesInf, "width"))
            me int64: numLines    <- entryWidth/editWidth+1
            me string: entryText  <- fetchStringField(dataInf)
            if(sourceID=="agent:RESULT"){dr.addC(cmdSetColor, styler.Yellow)}
            else if(sourceID=="agent:SYSERR"){dr.addC(cmdSetColor, styler.Red)}
            else if(sourceID=="agent:SYNERR"){dr.addC(cmdSetColor, styler.Pink)}
            else if(sourceID=="agent:NRMERR"){dr.addC(cmdSetColor, styler.Green)}
            else {dr.addC(cmdSetColor, titleTextColr)}
            dr.addTF(cmdRenderText, xCur, yCur+(lineHeight/2)+(styler.smallFont.height/2-3), entryText, styler.smallFont)
            yCur <+- lineHeight
            crntLineNum <+- numLines
            pov <- pov.next
        }

        // Draw the currently-being-edited line
        our ParamRec:: innerPR; innerPR.init(dataItems.back(), xCur, yCur, width-10, lineHeight)
        innerPR.topPov  <- PR.topPov
        innerPR.font    <- styler.smallFont
        innerPR.title   <- "NO_PROMPT"
        innerPR.parentCtrlsData <- termBoxGDR
        innerPR.viewStyleTagArg <- "_edit"
        innerPR.viewStyleTag    <- "genericstring_edit"
        innerPR.viewStyleCtrl   <- widgetMngr.getviewStyleTagCtrl("genericstring_edit")
        if(proactiveGUI.presenter.modelMgr.isPovTopWindow(PR.topPov)){innerPR.startActive <- true}
        proactiveGUI.presenter.drawItem(dr, innerPR)
    }

    void: processResult(me string: buffer) <- { // Process result messages from parse / extract / normalize
        log("PROCESS_RESULT:" + buffer + "\n")
        // Extract result-type, charPos, mesg
        me string: resultType <- buffer.subStr(0,6)
        buffer <- buffer.subStr(7)
        me int: colonPos <- buffer.find(":")
        me uint64: charPos <- stol(buffer.subStr(0,colonPos))
        buffer <- buffer.subStr(colonPos+1)

        our infon: newInfon <- thisPR.dataPov.makePotentialMemberInfon()
        newInfon.infCharPos <- charPos   // Remember our position in the stream

        // Now search backwards to find the correct slot to insert this.
        our POV: prevPov <- thisPR.dataPov.pItem.value.items.back()
        while(prevPov!=NULL and prevPov.pItem.infCharPos > charPos){
            prevPov <- prevPov.prev
        }
        our POV: newPov <- thisPR.dataPov.pItem.value.items.insertAfter(prevPov, newInfon)
        if(newPov!=NULL){
            our POV: newProps <- fetchField(newPov, "properties")
            our POV: dataInf  <- fetchField(newPov, "data")
            our POV: newSrcID <- fetchField(newProps, "sourceid")
            dataInf.pItem.value.format  <- fLiteral
            dataInf.pItem.value.str     <- buffer
            newSrcID.pItem.value.format <- fLiteral
            newSrcID.pItem.value.str    <- "agent:"+resultType
        }
    }

    void: processEntry(me string: buffer) <- {
        // This runs when user hits Enter  / submits text on terminal.
        if(iStream!=NULL){
            iStream.pushParserInputBuf(buffer+"\n")
        }
        our POV: newPov <- thisPR.dataPov.tryAddingTentativeChild()
        if(newPov!=NULL){
            newPov.pItem.infCharPos <- iStream.source.inputBuf.crntStreamSize
            our POV: newProps <- fetchField(newPov, "properties")
            our POV: newSrcID <- fetchField(newProps, "sourceid")
            if(newSrcID==NULL){} //DO_NOW: MAKE AND PLACE SourceID
            newSrcID.pItem.value.format <- fLiteral
            newSrcID.pItem.value.str <- "user"
        }

    }
}
